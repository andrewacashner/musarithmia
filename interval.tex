\input cwebmac
% This program is copyright (c) 2015 Andrew A. Cashner.
%
% v0	2015-04-12	First working prototype
% v1	2015-04-20	Improved

\def\title{Interval Calculator}
\def\emph #1{\bgroup\it#1\/\egroup}
\def\term{\emph}
\def\q#1{``#1''}


\N{1}{1}Introduction.
This is \.{interval}, a program to calculate musical intervals by Andrew
Cashner, \today.
The user provides a command in the form of (1) a starting pitch with its octave
and accidental, and (2) an interval degree and quality to add or subtract.
The program outputs an ending pitch with its octave and accidental.

Musical pitches are grouped in octaves, which are divided into seven
\term{pitch classes} constituting the \term{diatonic series}.
These are lettered C, D, E, F, G, A, B, where each new octave starts
with C, and where these names (with no accidental) match the white keys on the
piano.
We assign each pitch class a number, where C is 0 and B is 6.
(A \term{pitch class} is, for example, all notes named C, regardless of their
octave).

There are twelve semitones in each octave, constituting the \term{chromatic
series}.
The diatonic pitches are spaced at intervals of semitones and tones in an
asymmetrical pattern (the intervals in an octave from C to C are
T--T--ST--T--T--T--ST).
Each diatonic pitch therefore has a chromatic code corresponding to its
distance
in semitones from C natural: the series is 0, 2, 4, 5, 7, 9, 11 for C through
B.

The whole series of diatonic pitches may be mapped to index numbers starting
with C$_0$---these are the \term{absolute diatonic pitch numbers}.
The octave number and pitch-class number may be thought of as two digits of a
base-7 number: the octave number is the \q{sevens} digit, and the pitch-class
number is the \q{ones} digit.
The absolute diatonic pitch number is a decimal representation of that base-7
number.
For example, \q{middle C} is C$_4$; so the pair $\{octave, pitch class\}$
is $\{4, 0\}$.
Since $7 * 4 + 0 = 28$, C$_4$ has the absolute diatonic pitch number 28.

The whole series of \emph{chromatic} pitches may also be mapped to index
numbers
starting with C$_0$---these are the \term{absolute chromatic pitch numbers}.
Now the pair of octave and pitch-class number correspond to the two digits of a
base-\emph{twelve} number, which we can convert to a decimal representation to
get the absolute chromatic pitch number.
For middle C, the pair $\{4, 0\}$, since $12 * 4 + 0 = 48$, the absolute
chromatic pitch number is 48.

To calculate the end pitch class and octave, first we convert the start octave
and pitch class (taken as two digits of a base-seven number) into decimal form.
The given interval degree (minus one since we count from zero) is also
diatonic,
so we add it to the absolute diatonic pitch-class number to get the end
absolute
diatonic pitch-class number.
To get the end octave and pitch class, we convert the decimal number back to
the
two base-seven digits: the \q{sevens} become the octave and the \q{ones} become
the pitch class.

Calculating the end accidental is more complicated because we must use the
chromatic series.
The codes for the accidentals are $-1$ for flat, 0 for natural, and $+1$ for
sharp.
The end-accidental code is the difference between the ending absolute chromatic
pitch number and the absolute chromatic pitch number of the ending \emph{base
pitch}.
If the end pitch is calculated to be absolute chromatic pitch number 49,
enharmonically this could correspond to several pitch names (e.g., C$\sharp$
or D$\flat$).
From the diatonic calculation already discussed, we know in this example that
the \emph{base diatonic pitch} is C.
So the end accidental is the difference between 49 and the absolute chromatic
pitch number of C$\natural$ (48).
The result is $+1$, so the end note is C$\sharp$.

To calculate the absolute chromatic pitch number of the end note, we first
calculate the chromatic pitch number of the start note, by treating the pair
$\{octave, pitch class\}$ as two digits in base 12, and converting to a decimal
representation of this base-12 number.
To this we add the code for the start accidental.
So C$\sharp_4$ is $12 * 4 + 0 + 1 = 49$.

Next we need to add the chromatic interval, the number of chromatic steps.
For this we need to convert the diatonic interval to a chromatic interval and
then add the code for the interval quality.
(In the input routine we test for proper matches of interval degree and
interval
quality---thirds cannot be perfect and fifths cannot be major, for example.)
The diatonic interval is already the decimal version of a base-seven diatonic
interval, so we must obtain the pair $\{octave, pitch class\}$,
and then use functions to convert that to the decimal representation of a
base-\emph{twelve} number.
To that we add the interval-quality code.
Adding the chromatic interval to the start chromatic pitch number we get the
ending absolute chromatic pitch number.
We use that to calculate the end accidental.

For example, we convert the interval of a minor ninth (code 8) as follows:
8 (decimal representation of base-7 number) converts to the pair $\{1,1\}$.
We convert the \q{ones} digit to a chromatic code using the chromatic series
described earlier: 1 diatonic step equals 2 semitones in the chromatic series.
So that pair converts to decimal representation of base-12 as $12 * 1 + 2 =
14$.

We convert the integer values back to the proper character symbols and output
the results.

\Y\B\8\#\&{include} \.{<stdio.h>}\6
\8\#\&{include} \.{<stdlib.h>}\7
\X2:Constants\X\6
\X3:Global variables\X\6
\X5:Function prototypes\X\7
\&{int} \\{main}(\&{int} \\{argc}${},\39{}$\&{char} ${}{*}\\{argv}[\,]){}$\1\1%
\2\2\6
${}\{{}$\1\6
\X9:Main variables\X\6
\X10:Validate and store input\X\6
\X21:Compute diatonic end pitch and octave\X\6
\X23:Compute end accidental\X\6
\X25:Print output\X\6
\&{return} (\T{0});\6
\4${}\}{}$\2\par
\fi

\M{2}These constant arrays allow us to encode and decode accidentals and
interval qualities.
\PB{\\{dia\_to\_chrom}} allows conversion between diatonic and chromatic pitch
classes
and interval qualities.
There are pairs of arrays for the accidental and interval quality.
There is no need to use a \PB{\&{struct}} because we can easily access them by
name and
array index.

The diminished interval quality for an imperfect interval is actually $-2$;
during the input validation we test for imperfect intervals, and if imperfect
and diminished, we decrease the \PB{\\{interval\_quality}} by 1.

\Y\B\4\X2:Constants\X${}\E{}$\6
\&{static} \&{const} \&{int} \\{dia\_to\_chrom}[\,]${}\K\{\T{0},\39\T{2},\39%
\T{4},\39\T{5},\39\T{7},\39\T{9},\39\T{11}\}{}$;\C{ $ C = 0, D = 2, \dots, B =
11 $ }\7
\&{static} \&{const} \&{int} \\{accidental\_code}[\,]${}\K\{{-}\T{2},\39{-}%
\T{1},\39\T{0},\39\T{1},\39\T{2}\};{}$\6
\&{static} \&{const} \&{char} \\{accidental\_name}[\,]${}\K\{\.{'B'},\39%
\.{'b'},\39\.{'n'},\39\.{'s'},\39\.{'X'}\}{}$;\7
\&{static} \&{const} \&{int} \\{interval\_quality\_code}[\,]${}\K\{{-}\T{1},%
\39{-}\T{1},\39\T{0},\39\T{0},\39\T{1}\};{}$\6
\&{static} \&{const} \&{char} \\{interval\_quality\_name}[\,]${}\K\{\.{'d'},\39%
\.{'m'},\39\.{'M'},\39\.{'P'},\39\.{'a'}\}{}$;\7
\X26:Error message strings\X\par
\U1.\fi

\M{3}We use the boolean switch \PB{\\{found}} for scanning through the constant
arrays to find a match.
We use \PB{\\{perfect\_interval}} to mark the interval quality for testing.

\Y\B\4\X3:Global variables\X${}\E{}$\6
\&{typedef} \&{enum} ${}\{{}$\1\6
${}\.{FALSE},\39\.{TRUE}{}$\2\6
${}\}{}$ \&{boolean};\6
\&{boolean} \\{found};\6
\&{boolean} \\{perfect\_interval};\par
\U1.\fi

\N{1}{4}Functions for converting to and from base ten.

\fi

\M{5}Function: Convert decimal number to pair of digits in a given base.
The function receives the addresses of \PB{\&{int}} variables used in the main
routine.

\Y\B\4\X5:Function prototypes\X${}\E{}$\6
\&{void} \\{convert\_from\_base\_ten}(\&{int} \\{base}${},\39{}$\&{int} %
\\{input}${},\39{}$\&{int} ${}{*}\\{main\_tens},\39{}$\&{int} ${}{*}\\{main%
\_ones}){}$;\par
\As7\ET27.
\U1.\fi

\M{6}The function does the same thing as the following, but at lower cost:
\PB{$\\{ones}\K\\{input}\MOD\\{base};{}$ ${}\\{tens}\K\\{input}/\\{base};$}

\Y\B\&{void} \\{convert\_from\_base\_ten}(\&{int} \\{base}${},\39{}$\&{int} %
\\{input}${},\39{}$\&{int} ${}{*}\\{main\_tens},\39{}$\&{int} ${}{*}\\{main%
\_ones}){}$\1\1\2\2\6
${}\{{}$\1\6
\&{int} \\{tens}${},{}$ \\{ones};\7
${}\\{tens}\K\T{0};{}$\6
${}\\{ones}\K\\{input};{}$\6
\&{while} ${}(\\{ones}>\\{base}){}$\5
${}\{{}$\1\6
${}\\{ones}\MRL{-{\K}}\\{base};{}$\6
${}\PP\\{tens};{}$\6
\4${}\}{}$\2\6
${}{*}\\{main\_tens}\K\\{tens};{}$\6
${}{*}\\{main\_ones}\K\\{ones};{}$\6
\&{return};\6
\4${}\}{}$\2\par
\fi

\M{7}Function: The reverse, convert a pair of digits in a given base to a
decimal number.

\Y\B\4\X5:Function prototypes\X${}\mathrel+\E{}$\6
\&{int} \\{convert\_to\_base\_ten}(\&{int} \\{base}${},\39{}$\&{int} %
\\{multiples}${},\39{}$\&{int} \\{ones});\par
\fi

\M{8}The \PB{\\{multiples}} are the \q{bases} columns (\q{tens} in base ten).

\Y\B\&{int} \\{convert\_to\_base\_ten}(\&{int} \\{base}${},\39{}$\&{int} %
\\{multiples}${},\39{}$\&{int} \\{ones})\1\1\2\2\6
${}\{{}$\1\6
\&{int} \\{result};\7
${}\\{result}\K\\{base}*\\{multiples}+\\{ones};{}$\6
\&{return} (\\{result});\6
\4${}\}{}$\2\par
\fi

\N{1}{9}Process input.
There are six arguments required for a valid interval-calculation command:

\def\ttchar #1{%
{\tt '#1'}\ %
}

\item{1.} pitch-class name (\ttchar{C}, \ttchar{D}, \ttchar{E},
\ttchar{F}, \ttchar{G}, \ttchar{A}, \ttchar{B})
\item{2.} accidental (\ttchar{s} for sharp, \ttchar{n} for natural,
\ttchar{b} for flat; \ttchar{X} for double sharp; \ttchar{B} for double flat)
\item{3.} octave number (\ttchar{0}--\ttchar{20}), where middle C is octave 4
\item{4.} operator (\ttchar{+} or \ttchar{-})
\item{5.} interval quality (\ttchar{M} for major, \ttchar{m} for minor,
\ttchar{P} for perfect, \ttchar{a} for augmented, \ttchar{d} for diminished)
\item{6.} interval degree (\ttchar{1}--\ttchar{70})

\Y\B\4\X9:Main variables\X${}\E{}$\6
\&{int} \|i;\C{ Loop counter }\6
\&{int} \\{start\_pitchclass};\C{ Integer 0--6 representing pitch C--B }\6
\&{int} \\{start\_accidental};\C{  From \PB{\\{accidental\_code}} }\6
\&{int} \\{start\_octave};\C{ Octave number of starting pitch  }\6
\&{int} \\{operator};\C{ -1 if '-', +1 if '+' }\6
\&{int} \\{interval\_quality};\C{ From \PB{\\{interval\_quality\_code}} }\6
\&{char} \\{interval\_quality\_name\_in};\C{ Character input, should match one
of \PB{\\{interval\_quality\_name}} }\6
\&{int} \\{interval\_dia};\C{ The absolute diatonic interval, one less than
input (e.g., a tenth becomes 9) }\par
\As18, 20, 22\ETs24.
\U1.\fi

\M{10}Check each argument for valid input; if valid, store it in the proper
format (everything becomes an \PB{\&{int}} code).
If not, exit with specific error message (called up from \PB{\&{error}} array
of strings).

For the pitch name, we convert the character into an \PB{\&{int}} 0--7, where C
is 0.
This means we have to adjust A and B to the end of the scale.


\Y\B\4\X10:Validate and store input\X${}\E{}$\6
\X11:Check number of arguments\X\6
\X12:Get pitch class\X\6
\X13:Get accidental\X\6
\X14:Get octave number\X\6
\X15:Get operator\X\6
\X16:Get interval quality\X\6
\X17:Get interval number\X\6
\X19:Check perfect vs. imperfect interval\X\par
\U1.\fi

\M{11}There must be seven arguments.

\Y\B\4\X11:Check number of arguments\X${}\E{}$\6
\&{if} ${}(\\{argc}\I\T{7}){}$\5
${}\{{}$\1\6
${}\\{exit\_error}(\.{ERROR\_ARGNUM},\39\NULL);{}$\6
\4${}\}{}$\2\par
\U10.\fi

\M{12}The pitch class must be entered as an uppercase character A--G.
We convert this to an \PB{\&{int}} code using the ASCII codes.
Since C is 0, we wrap A and B around to the end of the series.

\Y\B\4\X12:Get pitch class\X${}\E{}$\6
\&{if} ${}(\\{argv}[\T{1}][\T{1}]\I\.{'\\0'}\V\\{argv}[\T{1}][\T{0}]<\.{'A'}\V%
\\{argv}[\T{1}][\T{0}]>\.{'G'}){}$\5
${}\{{}$\1\6
${}\\{exit\_error}(\.{ERROR\_PITCH},\39\\{argv}[\T{1}]);{}$\6
\4${}\}{}$\2\6
${}\\{start\_pitchclass}\K{}$(\&{int}) \\{argv}[\T{1}][\T{0}]${}-\.{'C'};{}$\6
\&{if} ${}(\\{start\_pitchclass}<\T{0}){}$\5
${}\{{}$\C{ Adjust for A or B }\1\6
${}\\{start\_pitchclass}\MRL{+{\K}}\T{7};{}$\6
\4${}\}{}$\2\par
\U10.\fi

\M{13}We check for valid accidental input and convert to \PB{\&{int}} code by
matching the
index of \PB{\\{accidental\_name}} to \PB{\\{accidental\_code}}.

\Y\B\4\X13:Get accidental\X${}\E{}$\6
\&{if} ${}(\\{argv}[\T{2}][\T{1}]\I\.{'\\0'}){}$\5
${}\{{}$\1\6
${}\\{exit\_error}(\.{ERROR\_ACCIDENTAL},\39\\{argv}[\T{2}]);{}$\6
\4${}\}{}$\2\6
\&{for} ${}(\|i\K\T{0},\39\\{found}\K\.{FALSE};{}$ ${}\\{accidental\_name}[\|i]%
\I\.{'\\0'};{}$ ${}\PP\|i){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{argv}[\T{2}][\T{0}]\E\\{accidental\_name}[\|i]){}$\5
${}\{{}$\1\6
${}\\{found}\K\.{TRUE};{}$\6
${}\\{start\_accidental}\K\\{accidental\_code}[\|i];{}$\6
\&{break};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{found}\E\.{FALSE}){}$\5
${}\{{}$\1\6
${}\\{exit\_error}(\.{ERROR\_ACCIDENTAL},\39\\{argv}[\T{2}]);{}$\6
\4${}\}{}$\2\par
\U10.\fi

\M{14}Scan octave number and make sure it is within range.

\Y\B\4\X14:Get octave number\X${}\E{}$\6
$\\{sscanf}(\\{argv}[\T{3}],\39\.{"\%d"},\39{\AND}\\{start\_octave});{}$\6
\&{if} ${}(\\{start\_octave}<\T{0}\V\\{start\_octave}>\T{20}){}$\5
${}\{{}$\1\6
${}\\{exit\_error}(\.{ERROR\_OCTAVE},\39\\{argv}[\T{3}]);{}$\6
\4${}\}{}$\2\par
\U10.\fi

\M{15}The code for the operator is $-1$ or $+1$ depending on the input.

\Y\B\4\X15:Get operator\X${}\E{}$\6
\&{if} ${}(\\{argv}[\T{4}][\T{1}]\I\.{'\\0'}){}$\5
${}\{{}$\1\6
${}\\{exit\_error}(\.{ERROR\_OPERATOR},\39\\{argv}[\T{4}]);{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{switch} (\\{argv}[\T{4}][\T{0}])\5
${}\{{}$\1\6
\4\&{case} \.{'-'}:\5
${}\\{operator}\K{-}\T{1};{}$\6
\&{break};\6
\4\&{case} \.{'+'}:\5
${}\\{operator}\K\T{1};{}$\6
\&{break};\6
\4\&{default}:\5
${}\\{exit\_error}(\.{ERROR\_OPERATOR},\39\\{argv}[\T{4}]);{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U10.\fi

\M{16}As with the accidental, we convert interval quality character input
to \PB{\&{int}} code using constant array \PB{\\{interval\_quality\_code}}.

\Y\B\4\X16:Get interval quality\X${}\E{}$\6
\&{if} ${}(\\{argv}[\T{5}][\T{1}]\I\.{'\\0'}){}$\5
${}\{{}$\1\6
${}\\{exit\_error}(\.{ERROR\_INTERVAL\_QUALITY},\39\\{argv}[\T{5}]);{}$\6
\4${}\}{}$\2\6
\&{for} ${}(\|i\K\T{0},\39\\{found}\K\.{FALSE};{}$ ${}\\{interval\_quality%
\_name}[\|i]\I\.{'\\0'};{}$ ${}\PP\|i){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{argv}[\T{5}][\T{0}]\E\\{interval\_quality\_name}[\|i]){}$\5
${}\{{}$\1\6
${}\\{found}\K\.{TRUE};{}$\6
${}\\{interval\_quality\_name\_in}\K\\{argv}[\T{5}][\T{0}];{}$\6
${}\\{interval\_quality}\K\\{interval\_quality\_code}[\|i];{}$\6
\&{break};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{found}\E\.{FALSE}){}$\5
${}\{{}$\1\6
${}\\{exit\_error}(\.{ERROR\_INTERVAL\_QUALITY},\39\\{argv}[\T{5}]);{}$\6
\4${}\}{}$\2\par
\U10.\fi

\M{17}Get the interval number, check the range, and subtract one since we count
from zero.

\Y\B\4\X17:Get interval number\X${}\E{}$\6
$\\{sscanf}(\\{argv}[\T{6}],\39\.{"\%d"},\39{\AND}\\{interval\_dia});{}$\6
\&{if} ${}(\\{interval\_dia}<\T{1}\V\\{interval\_dia}>\T{70}){}$\5
${}\{{}$\1\6
${}\\{exit\_error}(\.{ERROR\_INTERVAL\_DEGREE},\39\\{argv}[\T{6}]);{}$\6
\4${}\}{}$\2\6
${}\MM\\{interval\_dia}{}$;\C{ Interval entered as \.{'10'} really means add 9
}\par
\U10.\fi

\M{18}Check perfect vs. imperfect interval.

\Y\B\4\X9:Main variables\X${}\mathrel+\E{}$\6
\&{int} \\{interval\_octaves};\C{ Number of octaves in interval (the %
\q{multiples} digit of the interval in base 7 }\6
\&{int} \\{interval\_steps\_dia};\C{ Diatonic steps in the interval in addition
to octaves (the \q{ones} digit of the interval in base 7 }\par
\fi

\M{19}The interval quality and interval degree must agree; the perfect
intervals
(unison, fourth, fifth) can only have perfect, augmented, and diminished
qualities, and the imperfect intervals cannot have perfect quality.
Imperfect intervals with diminished quality have $-2$ value, versus $-1$ for
diminished perfect intervals.

We convert the input interval to \PB{\\{interval\_octaves}} and \PB{\\{interval%
\_steps\_dia}},
the two base-7 digits, and test \PB{\\{interval\_steps\_dia}}.
We will use both variables later when computing the \PB{\\{end\_accidental}}.

\Y\B\4\X19:Check perfect vs. imperfect interval\X${}\E{}$\6
$\\{interval\_octaves}\K\\{interval\_steps\_dia}\K\T{0};{}$\6
${}\\{convert\_from\_base\_ten}(\T{7},\39\\{interval\_dia},\39{\AND}\\{interval%
\_octaves},\39{\AND}\\{interval\_steps\_dia}){}$;\7
\&{switch} (\\{interval\_steps\_dia})\5
${}\{{}$\C{ Test for perfect vs. imperfect interval }\1\6
\4\&{case} \T{0}:\5
\&{case} \T{3}:\5
\&{case} \T{4}:\5
${}\\{perfect\_interval}\K\.{TRUE};{}$\6
\&{break};\6
\4\&{default}:\5
${}\\{perfect\_interval}\K\.{FALSE};{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{perfect\_interval}\E\.{TRUE}){}$\5
${}\{{}$\C{ Perfect interval, cannot be \.{'m'} or \.{'M'} }\1\6
\&{switch} (\\{interval\_quality\_name\_in})\5
${}\{{}$\1\6
\4\&{case} \.{'m'}:\5
\&{case} \.{'M'}:\5
${}\\{exit\_error}(\.{ERROR\_MISMATCH\_INTERVAL\_QUALITY},\39\NULL);{}$\6
\&{break};\6
\4\&{default}:\C{ Do nothing }\6
;\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\C{ Imperfect interval: Cannot be \.{'P'}, if \.{'d'} then value should
be one less }\1\6
\&{switch} (\\{interval\_quality\_name\_in})\5
${}\{{}$\1\6
\4\&{case} \.{'P'}:\5
${}\\{exit\_error}(\.{ERROR\_MISMATCH\_INTERVAL\_QUALITY},\39\NULL);{}$\6
\&{break};\6
\4\&{case} \.{'d'}:\5
${}\MM\\{interval\_quality}{}$;\C{ Imperfect diminished $= -2$ }\6
\&{break};\6
\4\&{default}:\C{ Do nothing }\6
;\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U10.\fi

\N{1}{20}Compute the diatonic end pitch and octave.

\Y\B\4\X9:Main variables\X${}\mathrel+\E{}$\6
\&{int} \\{start\_abs\_pitch\_dia};\C{ Starting diatonic pitch: Absolute
diatonic pitch number, base 10 }\6
\&{int} \\{end\_abs\_pitch\_dia};\C{ Ending diatonic pitch number }\6
\&{int} \\{end\_pitchclass};\6
\&{int} \\{end\_octave};\par
\fi

\M{21}Get starting absolute diatonic pitch number, add the interval, convert
back to
base-seven pair of octave and pitchclass.

\Y\B\4\X21:Compute diatonic end pitch and octave\X${}\E{}$\6
$\\{start\_abs\_pitch\_dia}\K\\{convert\_to\_base\_ten}(\T{7},\39\\{start%
\_octave},\39\\{start\_pitchclass});{}$\6
${}\\{end\_abs\_pitch\_dia}\K\\{start\_abs\_pitch\_dia}+\\{operator}*%
\\{interval\_dia};{}$\6
${}\\{end\_pitchclass}\K\\{end\_octave}\K\T{0}{}$;\C{ Initialize before passing
to function }\6
${}\\{convert\_from\_base\_ten}(\T{7},\39\\{end\_abs\_pitch\_dia},\39{\AND}%
\\{end\_octave},\39{\AND}\\{end\_pitchclass});{}$\6
\&{if} ${}(\\{end\_octave}<\T{0}){}$\5
${}\{{}$\1\6
${}\\{exit\_error}(\.{ERROR\_OCTAVE\_RANGE},\39\NULL);{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{end\_pitchclass}<\T{0}\V\\{end\_pitchclass}>\T{6}){}$\5
${}\{{}$\1\6
${}\\{exit\_error}(\.{ERROR\_ENDPITCH\_RANGE},\39\NULL);{}$\6
\4${}\}{}$\2\par
\U1.\fi

\N{1}{22}Compute the end accidental.

\Y\B\4\X9:Main variables\X${}\mathrel+\E{}$\6
\&{int} \\{end\_accidental};\C{ \PB{\\{accidental\_code}} of ending accidental
}\6
\&{int} \\{start\_abs\_pitch\_chrom};\C{ Absolute chromatic number of starting
pitch }\6
\&{int} \\{end\_abs\_pitch\_chrom};\C{ Same for ending pitch }\6
\&{int} \\{end\_base\_pitch\_chrom};\C{ Abs. chromatic number of ending %
\emph{base} pitch  (e.g., if end is C$\sharp$, base pitch is C$\natural$) }\6
\&{int} \\{interval\_chrom};\C{ Chromatic interval (number of semitones) }\par
\fi

\M{23}We compute the end accidental by first calculating the number of the
starting
pitch in a base-12 chromatic system.
We convert the diatonic pitch to chromatic using the constant array \PB{\\{dia%
\_to\_chrom}}.

To this we add a chromatic interval computed from the interval degree, adjusted
by the interval quality.
First we use \PB{\\{dia\_to\_chrom}} again to calculate the chromatic interval
degree.

The end accidental is the difference between the end chromatic pitch calculated
this way (module 12) and the chromatic equivalent of the end diatonic pitch.

For example, C$\sharp_1$ is chromatic pitch number 13. C$\sharp_1 - m2$ should
B$\sharp_0$.
The end chromatic pitch number is 12, and since $ 13 - 12 = 1 $, the end
accidental code is 1, or sharp.
This accidental is added to the base diatonic pitch, already calculated to be
B.

\Y\B\4\X23:Compute end accidental\X${}\E{}$\6
$\\{start\_abs\_pitch\_chrom}\K\\{convert\_to\_base\_ten}(\T{12},\39\\{start%
\_octave},\39\\{dia\_to\_chrom}[\\{start\_pitchclass}])+\\{start%
\_accidental}{}$;\7
${}\\{interval\_chrom}\K\\{convert\_to\_base\_ten}(\T{12},\39\\{interval%
\_octaves},\39\\{dia\_to\_chrom}[\\{interval\_steps\_dia}])+\\{interval%
\_quality}{}$;\7
${}\\{end\_abs\_pitch\_chrom}\K\\{start\_abs\_pitch\_chrom}+\\{operator}*%
\\{interval\_chrom}{}$;\7
${}\\{end\_base\_pitch\_chrom}\K\\{convert\_to\_base\_ten}(\T{12},\39\\{end%
\_octave},\39\\{dia\_to\_chrom}[\\{end\_pitchclass}]){}$;\7
${}\\{end\_accidental}\K\\{end\_abs\_pitch\_chrom}-\\{end\_base\_pitch%
\_chrom}{}$;\par
\U1.\fi

\N{1}{24}Return output.

We convert the pitch class code back to a char by adding it to \.{'C'}.
A and B must be converted to negative numbers by subtracting 7.

\Y\B\4\X9:Main variables\X${}\mathrel+\E{}$\6
\&{char} \\{end\_pitchclass\_symb};\6
\&{char} \\{end\_accidental\_symb};\par
\fi

\M{25}We convert accidental codes to characters by indexing the array \PB{%
\\{accidental\_name}} by \PB{$\\{end\_accidental}+\T{2}$}.

\Y\B\4\X25:Print output\X${}\E{}$\6
$\\{end\_accidental}\MRL{+{\K}}\T{2};{}$\6
\&{if} ${}(\\{end\_accidental}<\T{0}\V\\{end\_accidental}>\T{4}){}$\5
${}\{{}$\1\6
${}\\{exit\_error}(\.{ERROR\_ENDACCIDENTAL\_RANGE},\39\NULL);{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{end\_pitchclass}>\T{4}){}$\5
${}\{{}$\1\6
${}\\{end\_pitchclass}\MRL{-{\K}}\T{7};{}$\6
\4${}\}{}$\2\6
${}\\{end\_pitchclass\_symb}\K(\&{char})(\\{end\_pitchclass}+\.{'C'});{}$\6
${}\\{end\_accidental\_symb}\K\\{accidental\_name}[\\{end\_accidental}];{}$\6
${}\\{printf}(\.{"\%c\ \%c\ \%d\\n"},\39\\{end\_pitchclass\_symb},\39\\{end%
\_accidental\_symb},\39\\{end\_octave}){}$;\par
\U1.\fi

\N{1}{26}Error messages.
These are the error messages to print before exiting; they are indexed by the %
\PB{\&{enum}} labels.

\Y\B\4\X26:Error message strings\X${}\E{}$\6
\&{static} \&{const} \&{char} ${}{*}$ \&{error} [\,] $\K$ $\{\.{"There\ must\
be\ six\ a}\)\.{rguments\ after\ the\ p}\)\.{rogram\ name.\\n"}\.{"Usage:\
interval\ <pi}\)\.{tch\ class>\ <accident}\)\.{al>\ <octave>\ <+\ or\ -}\)\.{>\
<interval\ quality>}\)\.{\ <interval\ degree>\\n}\)\.{"},\39\.{"Incorrect\
pitch\ nam}\)\.{e\ '\%s'.\ Should\ be\ le}\)\.{tter\ A-G.\\n"},\39%
\.{"Accidental\ can\ only}\)\.{\ be\ 'B',\ 'b',\ 'n',\ '}\)\.{s',\ or\ 'X'.\
You\ ente}\)\.{red\ '\%s'.\\n"},\39\.{"Octave\ number\ must\ }\)\.{be\ between\
0\ and\ 20.}\)\.{\ You\ entered\ '\%s'.\\n}\)\.{"},\39\.{"Operator\ must\ be\ +%
\ }\)\.{or\ -.\ You\ entered\ '\%}\)\.{s'.\\n"},\39\.{"Interval\ quality\ ca}\)%
\.{n\ only\ be\ 'd',\ 'm',\ }\)\.{'M',\ 'P',\ or\ 'a'.\ Yo}\)\.{u\ entered\ '%
\%s'.\\n"},\39\.{"Interval\ degree\ mus}\)\.{t\ be\ between\ 1\ and\ 7}\)\.{0.\
You\ entered\ '\%s'.}\)\.{\\n"},\39\.{"Mismatch\ of\ interva}\)\.{l\ quality\
and\ degree}\)\.{.\ 'P'\ not\ allowed\ wi}\)\.{th\ imperfect\ interva}\)\.{ls;\
'm',\ 'M'\ not\ all}\)\.{owed\ with\ perfect.\\n}\)\.{"},\39\.{"Result\ octave\
canno}\)\.{t\ be\ lower\ than\ 0.\ C}\)\.{alculation\ stopped.\\}\)\.{n"},\39%
\.{"Computation\ error:\ }\)\.{Result\ pitchclass\ is}\)\.{\ out\ of\ range.%
\\n"},\39\.{"Computation\ error:\ }\)\.{End\ accidental\ is\ ou}\)\.{t\ of\
range.\\n"}\};{}$\7
\&{static} \&{const} \&{enum} ${}\{{}$\1\6
${}\.{ERROR\_ARGNUM},\39\.{ERROR\_PITCH},\39\.{ERROR\_ACCIDENTAL},\39\.{ERROR%
\_OCTAVE},\39\.{ERROR\_OPERATOR},\39\.{ERROR\_INTERVAL\_QUALITY},\39\.{ERROR%
\_INTERVAL\_DEGREE},\39\.{ERROR\_MISMATCH\_INTERVAL\_QUALITY},\39\.{ERROR%
\_OCTAVE\_RANGE},\39\.{ERROR\_ENDPITCH\_RANGE},\39\.{ERROR\_ENDACCIDENTAL%
\_RANGE}{}$\2\6
${}\}{}$ \\{error\_msg};\par
\U2.\fi

\M{27}Function: Exit with an error message.

\Y\B\4\X5:Function prototypes\X${}\mathrel+\E{}$\6
\&{void} \\{exit\_error}(\&{int} \\{msg\_code}${},\39{}$\&{char} ${}{*}%
\\{arg}){}$;\par
\fi

\M{28}The function prints an error message from the array of \PB{\&{error}}
strings and
exits.

\Y\B\&{void} \\{exit\_error}(\&{int} \\{msg\_code}${},\39{}$\&{char} ${}{*}%
\\{arg}){}$\1\1 $\{$ \\{fprintf} $(\\{stderr},\39$ \&{error} [\\{msg\_code}]
$,$ \\{arg} )  ;\6
\\{exit}(\.{EXIT\_FAILURE}); $\}{}$\par
\fi


\inx
\fin
\con
